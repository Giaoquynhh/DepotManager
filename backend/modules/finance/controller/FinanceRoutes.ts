import { Router } from 'express';
import invoiceCtrl from './InvoiceController';
import paymentCtrl from './PaymentController';
import serviceCatalogCtrl from './ServiceCatalogController';
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import { authenticate } from '../../../shared/middlewares/auth';
import { requireRoles } from '../../../shared/middlewares/rbac';

// C·∫•u h√¨nh multer cho upload EIR file
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    // S·ª≠ d·ª•ng ƒë∆∞·ªùng d·∫´n tuy·ªát ƒë·ªëi c·ªë ƒë·ªãnh
    const uploadPath = 'D:\\container35\\manageContainer\\backend\\uploads';
    
    // T·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a t·ªìn t·∫°i
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    
    // V·∫•n ƒë·ªÅ: req.body ch∆∞a ƒë∆∞·ª£c parse khi filename function ƒë∆∞·ª£c g·ªçi
    // Gi·∫£i ph√°p: S·ª≠ d·ª•ng originalname ƒë·ªÉ t·∫°o t√™n file t·∫°m th·ªùi
    // Sau ƒë√≥ s·∫Ω ƒë·ªïi t√™n file trong route handler
    const tempFilename = `EIR_TEMP_${uniqueSuffix}_${file.originalname}`;
    console.log('üìÅ Creating temporary filename:', tempFilename);
    cb(null, tempFilename);
  }
});

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB
  },
  fileFilter: (req, file, cb) => {
    // Ch·ªâ ch·∫•p nh·∫≠n PDF v√† h√¨nh ·∫£nh
    if (file.mimetype === 'application/pdf' || file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Ch·ªâ ch·∫•p nh·∫≠n file PDF ho·∫∑c h√¨nh ·∫£nh'));
    }
  }
});

const router = Router();

// Route ri√™ng cho customer xem h√≥a ƒë∆°n c·ªßa h·ªç (kh√¥ng c·∫ßn quy·ªÅn SaleAdmin)
router.get('/invoices/details', authenticate, (req, res) => invoiceCtrl.getCustomerInvoices(req as any, res));

// Route ri√™ng cho customer xem EIR (kh√¥ng c·∫ßn quy·ªÅn SaleAdmin)
router.get('/eir/container/:container_no', authenticate, async (req: any, res: any) => {
  try {
    const { container_no } = req.params;
    
    
    if (!container_no) {
      return res.status(400).json({ success: false, message: 'Container number l√† b·∫Øt bu·ªôc' });
    }

    // T√¨m request v√† EIR document
    const { PrismaClient } = require('@prisma/client');
    const prisma = new PrismaClient();
    
    const request = await prisma.serviceRequest.findFirst({
      where: { container_no: container_no },
      include: {
        docs: {
          where: { type: 'EIR', deleted_at: null },
          orderBy: { createdAt: 'desc' },
          take: 1
        }
      },
      orderBy: { createdAt: 'desc' }
    });


    if (!request || !request.docs.length) {
      return res.status(404).json({ success: false, message: 'Kh√¥ng t√¨m th·∫•y EIR cho container n√†y' });
    }

    // Ki·ªÉm tra quy·ªÅn: customer ch·ªâ c√≥ th·ªÉ xem EIR c·ªßa container h·ªç t·∫°o
    
    if (req.user.role === 'CustomerAdmin' || req.user.role === 'CustomerUser') {
      if (request.created_by !== req.user._id) {
        return res.status(403).json({ success: false, message: 'B·∫°n kh√¥ng c√≥ quy·ªÅn xem EIR c·ªßa container n√†y' });
      }
    }

    const eirDoc = request.docs[0];
    const filename = eirDoc.storage_key;
    const filePath = path.join('D:\\container35\\manageContainer\\backend\\uploads', filename);
    
    
    // Ki·ªÉm tra file c√≥ t·ªìn t·∫°i kh√¥ng
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ success: false, message: 'File EIR kh√¥ng t·ªìn t·∫°i tr√™n server' });
    }
    

    // L·∫•y th√¥ng tin file
    const stats = fs.statSync(filePath);
    const ext = path.extname(filename).toLowerCase();
    
    // Set content type d·ª±a tr√™n extension
    let contentType = 'application/octet-stream';
    if (ext === '.pdf') {
      contentType = 'application/pdf';
    } else if (['.png', '.jpg', '.jpeg', '.gif'].includes(ext)) {
      contentType = `image/${ext.slice(1)}`;
    }

    // Set headers
    res.setHeader('Content-Type', contentType);
    res.setHeader('Content-Length', stats.size);
    res.setHeader('Content-Disposition', `inline; filename="${eirDoc.name}"`);

    // Stream file
    const fileStream = fs.createReadStream(filePath);
    fileStream.pipe(res);

  } catch (error: any) {
    console.error('Error serving EIR file by container:', error);
    res.status(500).json({ 
      success: false, 
      message: error.message || 'L·ªói khi xem file' 
    });
  }
});

// Middleware authentication v√† RBAC cho c√°c route kh√°cnnan√†y ƒëoiƒëoi
router.use(authenticate, requireRoles('TechnicalDepartment','SystemAdmin'));

// Routes hi·ªán t·∫°i
router.get('/invoices', (req, res) => invoiceCtrl.list(req as any, res));
router.get('/invoices/details', (req, res) => invoiceCtrl.listWithDetails(req as any, res));
router.get('/invoices/containers-need-invoice', (req, res) => invoiceCtrl.getContainersNeedInvoice(req as any, res));
// API V2: danh s√°ch h√≥a ƒë∆°n k√®m d·ªØ li·ªáu chu·∫©n h√≥a cho UI
router.get('/invoices/v2', (req, res) => invoiceCtrl.listV2(req as any, res));
// Xu·∫•t PDF h√≥a ƒë∆°n
router.get('/invoices/:id/pdf', (req, res) => invoiceCtrl.exportPdf(req as any, res));
// ƒê√£ b·ªè endpoint xem chi ti·∫øt h√≥a ƒë∆°n theo y√™u c·∫ßu (lo·∫°i b·ªè n√∫t Xem ·ªü FE)
router.post('/invoices', (req, res) => invoiceCtrl.create(req as any, res));
router.patch('/invoices/:id', (req, res) => invoiceCtrl.patch(req as any, res));
router.post('/invoices/:id/issue', (req, res) => invoiceCtrl.issue(req as any, res));
router.post('/invoices/:id/cancel', (req, res) => invoiceCtrl.cancel(req as any, res));
router.delete('/invoices/cleanup', (req, res) => invoiceCtrl.cleanup(req as any, res));



// Routes m·ªõi
router.post('/upload/eir', upload.single('file'), async (req: any, res: any) => {
  try {
    console.log('üì§ Upload EIR request received:');
    console.log('  - req.body:', req.body);
    console.log('  - req.file:', req.file ? {
      filename: req.file.filename,
      originalname: req.file.originalname,
      size: req.file.size,
      path: req.file.path
    } : 'No file');
    
    if (!req.file) {
      return res.status(400).json({ success: false, message: 'Kh√¥ng c√≥ file ƒë∆∞·ª£c upload' });
    }

    const { container_no, type } = req.body;
    console.log('  - container_no:', container_no);
    console.log('  - type:', type);
    
    if (!container_no) {
      return res.status(400).json({ success: false, message: 'Container number l√† b·∫Øt bu·ªôc' });
    }

    // ƒê·ªïi t√™n file t·ª´ TEMP th√†nh t√™n ch√≠nh x√°c v·ªõi container number
    const oldFilePath = req.file.path;
    const oldFilename = req.file.filename;
    const fileExtension = path.extname(req.file.originalname);
    const newFilename = `EIR_${container_no}_${Date.now()}-${Math.round(Math.random() * 1E9)}${fileExtension}`;
    const newFilePath = path.join(path.dirname(oldFilePath), newFilename);
    
    try {
      fs.renameSync(oldFilePath, newFilePath);
      console.log('üìÅ ƒê√£ ƒë·ªïi t√™n file:', oldFilename, '‚Üí', newFilename);
      
      // C·∫≠p nh·∫≠t req.file ƒë·ªÉ s·ª≠ d·ª•ng t√™n m·ªõi
      req.file.filename = newFilename;
      req.file.path = newFilePath;
    } catch (renameError) {
      console.error('‚ùå L·ªói khi ƒë·ªïi t√™n file:', renameError);
      // N·∫øu kh√¥ng ƒë·ªïi t√™n ƒë∆∞·ª£c, v·∫´n ti·∫øp t·ª•c v·ªõi t√™n c≈©
    }

    // T√¨m request t∆∞∆°ng ·ª©ng v·ªõi container_no
    const { PrismaClient } = require('@prisma/client');
    const prisma = new PrismaClient();
    
    
    const request = await prisma.serviceRequest.findFirst({
      where: { container_no: container_no },
      orderBy: { createdAt: 'desc' }
    });

    if (!request) {
      console.log('‚ùå Kh√¥ng t√¨m th·∫•y request cho container:', container_no);
      return res.status(404).json({ 
        success: false, 
        message: `Kh√¥ng t√¨m th·∫•y request cho container ${container_no}` 
      });
    }

    console.log('‚úÖ T√¨m th·∫•y request:', request);

    // L∆∞u th√¥ng tin file v√†o database
    const document = await prisma.documentFile.create({
      data: {
        request_id: request.id,
        type: 'EIR',
        name: req.file.originalname,
        size: req.file.size,
        version: 1,
        uploader_id: req.user._id,
        storage_key: req.file.filename
      }
    });

    console.log('‚úÖ ƒê√£ l∆∞u EIR document v√†o database:', document);

    res.json({
      success: true,
      message: 'Upload EIR th√†nh c√¥ng',
      data: {
        filename: req.file.filename,
        originalname: req.file.originalname,
        size: req.file.size,
        mimetype: req.file.mimetype,
        container_no: container_no,
        request_id: request.id,
        document_id: document.id,
        upload_path: req.file.path
      }
    });
  } catch (error: any) {
    console.error('Error uploading EIR:', error);
    res.status(500).json({ 
      success: false, 
      message: error.message || 'L·ªói khi upload file' 
    });
  }
  });
  
  // Route EIR ƒë√£ ƒë∆∞·ª£c di chuy·ªÉn l√™n tr√™n ƒë·ªÉ cho ph√©p customer truy c·∫≠p
  
  // API ƒë·ªÉ xem file EIR theo filename
  router.get('/eir/:filename', async (req: any, res: any) => {
    try {
      const { filename } = req.params;
      
      if (!filename) {
        return res.status(400).json({ success: false, message: 'T√™n file l√† b·∫Øt bu·ªôc' });
      }

      const filePath = path.join('D:\\container35\\manageContainer\\backend\\uploads', filename);
      
      // Ki·ªÉm tra file c√≥ t·ªìn t·∫°i kh√¥ng
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ success: false, message: 'File kh√¥ng t·ªìn t·∫°i' });
      }

      // L·∫•y th√¥ng tin file
      const stats = fs.statSync(filePath);
      const ext = path.extname(filename).toLowerCase();
      
      // Set content type d·ª±a tr√™n extension
      let contentType = 'application/octet-stream';
      if (ext === '.pdf') {
        contentType = 'application/pdf';
      } else if (['.png', '.jpg', '.jpeg', '.gif'].includes(ext)) {
        contentType = `image/${ext.slice(1)}`;
      }

      // Set headers
      res.setHeader('Content-Type', contentType);
      res.setHeader('Content-Length', stats.size);
      res.setHeader('Content-Disposition', `inline; filename="${filename}"`);

      // Stream file
      const fileStream = fs.createReadStream(filePath);
      fileStream.pipe(res);

    } catch (error: any) {
      console.error('Error serving EIR file:', error);
      res.status(500).json({ 
        success: false, 
        message: error.message || 'L·ªói khi xem file' 
      });
    }
  });
  
  // Route c·∫≠p nh·∫≠t tr·∫°ng th√°i has_invoice - s·ª≠ d·ª•ng RequestStatusController
router.patch('/requests/:id/invoice-status', (req, res) => {
  // Redirect ƒë·∫øn RequestStatusController
  const { RequestStatusController } = require('../../requests/controllers/RequestStatusController');
  const requestStatusCtrl = new RequestStatusController();
  return requestStatusCtrl.updateInvoiceStatus(req, res);
});

// Routes kh√°c
router.get('/payments', (req, res) => paymentCtrl.list(req as any, res));
router.post('/payments', (req, res) => paymentCtrl.create(req as any, res));
router.get('/service-catalog', (req, res) => serviceCatalogCtrl.listServices(req as any, res));

export default router;



